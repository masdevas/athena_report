\clearpage
\section{Граф вычислений}
\subsection{Абстрактная модель}
\label{sec:abstractmodel}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{graph.png}
    \caption{Структура графа}
    \label{fig:graphstructure}
\end{figure}
Граф представляет собой абстракцию, содержащую хранилище вершин графа с которыми работает пользователь в данный момент (Sync Nodes), сохраненные в графе вершины (Owning Nodes) и множество рёбер (Topology).
\begin{itemize}
    \item \textbf{Sync Nodes} -- множество вершин, объекты которых находятся у пользователя, и с которыми пользователь может работать (изменять, добавлять ассоциирующиеся с ними ребра в граф и т.п.).
    \item \textbf{Owning Nodes} -- множество вершин, сохраненных в графе, доступ к которым пользователь не имеет (заполняется при уничтожении вершины, ассоциируемой с графом, или после явного сохранения вершины пользователем).
    \item \textbf{Topology} -- множество рёбер графа.
\end{itemize}
В данный момент фреймворк позволяет пользователю создать вершины следующих типов:
\begin{itemize}
	\item \textbf{Node} -- вершина, содержащая в себе функцию от результатов входящих в неё вершин.
	\item \textbf{InputNode} -- вершина, позволяющая вносить данные в граф из различных хранилищ данных. Также может служить для хранения параметра графа вычислений, изменяющегося во время процесса оптимизации. 
\end{itemize}
\subsection{Описание алгоритма обхода графа}
\label{sec:algtraverse}
\textbf{Постановка задачи}: Требуется выделить последовательность множеств вершин (назовем их кластерами), работа с которыми может проводиться независимо внутри множеств. Кроме того вершинам $i$-го кластера требуются данные только от вершин из предыдущих кластеров. Подобное разбиение позволит с легкостью записать граф в виде обычной программы на некотором языке программирования, а так же выполнить часть операций параллельно, эффективно задействуя многоядерные системы.
\par
Последовательность кластеров должна обладать следующим свойством: Пусть $(x_1, x_2)$ - произвольное ориентированное ребро в графе. Пусть вершина $x_i$ содержится в кластере с номером $C_i$. Тогда $C_1 < C_2$. Это свойство означает: если кластеры обрабатываются последовательно, начиная с нулевого, то для любой вершины будет верно, что при старте её обработки будут обработаны все входящие в неё вершины, а значит программа сможет работать с их результатами внутри текущей вершины. Для выполнения такого разбиения разработан специальный алгоритм. 
\par
\textbf{Замечание}: Сначала будет дано описание алгоритма для графа без ориентированных циклов, в котором любая вершина достижима из вершин нулевого кластера, а затем будут даны замечания о работе алгоритма в обходе графов, нарушающих это правило.
\begin{itemize}
	\item \textbf{Входные данные}: Множество вершин графа, разделенное на вектора вершин соответствующих типов, с указанием количества входящих в каждую вершину ребер и множество рёбер графа.
	\item \textbf{Выходные данные}: Последовательность кластеров вершин, обладаюшая вышеописанными свойствами. 
	\item \textbf{Алгоритм}: \begin{enumerate}
	    \item В множество вершин первого кластера заносятся все входные вершины графа. Их кластер назначается текущим.
	    \item Пока из вершин текущего кластера есть выходящие ребра, повторяем:
	    \begin{enumerate}
		\item Создаём новый пустой кластер.
	        \item Проходим по всем ребрам, выходящим из вершин текущего кластера и инкрементируем счетчик вхождений в иные вершины. Если счётчик числа вхождений в вершину достигает числа входящих в вершину рёбер - вершина добавляется в новый кластер.
		\item Назначаем новый кластер текущим и добавляем в последовательность. 
	    \end{enumerate}
	\end{enumerate}
\end{itemize}
\subsection{Доказательство корректности}
\label{sec:validalg}
\begin{lemma}\label{lemma1}
 Каждая вершина будет единожды добавлена в последовательность кластеров.
\end{lemma}
\begin{proof}
Рассмотрим моменты, когда вершина может быть добавлена в некоторый кластер:
\begin{itemize}
	\item Вершина является входной и добавляется в нулевой кластер.
	\item Вершина не является входной и добавляется в кластер, отличный от нулевого.
\end{itemize}
В любом из этих случаев на момент добавления в последовательность кластеров счётчик вхождений в вершину равен числу входящих в неё рёбер. Т.к. этот счётчик может лишь инкрементироваться (но не уменьшаться) такая ситуация более не повторится, а значит вершина не будет добавлена в какой-либо иной кластер.
\end{proof}
\par
Докажем корректность алгоритма методом математической индукции при условиях, описанных выше. 
\begin{itemize}
	\item \textbf{База индукции}: На нулевом шаге формируем нулевой кластер из всех входных вершин. Этот кластер сформирован корректно, т.к. между входными вершинами в графе нельзя строить ориентированные пути и предыдущих кластеров нет.
	\item \textbf{Шаг индукции}: Пусть на $i$-ом шаге корректно сформирован $i$-ый кластер. Начнем формировать $(i+1)$-ый кластер. Для этого создадим пустой кластер и, проходя по всем выходящим из $i$-ого кластера рёбрам, будем добавлять вершины-концы этих рёбер в этот кластер. Добавление каждой такой вершины в кластер будет происходить тогда, когда счётчик вхождений в неё будет инкрементирован обходами предшевствующих ей вершин в графе в процессе работы алгоритма число раз, равное числу входящих в неё рёбер. Т.к. рёбра, исходящие из вершин уже созданных кластеров будут пройдены алгоритмом единожды при добавлении этих вершин в последовательность кластеров (из Леммы \ref{lemma1}), то и все входящие в данную вершину рёбра будут пройдены единожды. При этом, т.к. рёбра были пройдены до добавления данной вершины в новый кластер, то и их вершины были ранее добавлены в последовательность кластеров. Следовательно, на всех входящих в данную вершину рёбрах требуемое свойство сохраняется. Таким образом корректность формирования $(i+1)$-ого кластера доказана.
\end{itemize}
\textbf{Замечание}: Данный алгоритм также позволяет проверить граф на ацикличность и на достижимость произвольной вершины из вершин нулевого кластера. \newline
\textbf{Решение}: Во время обхода графа считать число вершин, добавленных в кластеры и сравнивать его с полным числом вершин.
\begin{itemize}
	\item \textbf{Наличие ориентированных циклов}: Ориентированные циклы могут состоять только из вершин, которые могут иметь входящие и исходящие рёбра. При встрече алгоритма с вершиной ориентированного цикла он не сможет перейти в неё, т.к. существует ребро, являющееся частью этого цикла, но ещё не пройденное алгоритмом, ведь оно исходит из вершины, прежде которой надо посетить ту, в которую алгоритм пытается посетить в данный момент. Следовательно эта вершина не будет добавлена ни в один из кластеров.
	\item \textbf{Достижимость вершин}: Если до какой либо вершины не существует пути от вершин нулевого кластера то она не будет добавлена ни в один из кластеров, т.к. алгоритм переходит от вершины к вершине только вдоль ориентированных рёбер.
\end{itemize}
\subsection{Программное представление вершин}
\label{sec:softwarepresentationnodes}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{node_hierarchy.png}
    \caption{Иерархия классов вершин}
    \label{fig:nodes_hierarchy}
\end{figure}
Все типы вершин представлены иерархией классов, отображенной на рисунке \ref{fig:nodes_hierarchy}
\begin{itemize}
    \item \textbf{AbstractNode} -- абстрактный класс, инкапсулирующий общие для всех вершин поля: имя, число входящих рёбер, тензор результата.
    \item \textbf{Node} -- класс, позволяющий хранить операцию.
    \item \textbf{InputNode} -- класс, позволяющий хранить объект-загрузчик (loader), необходимый для загрузки данных в граф из сторонних источников.
\end{itemize}
\subsection{Программное представление графа}
\label{sec:softwarepresentationgraph}
Граф представлен классом Graph в пространстве имен athena::core. Основные его поля выполнены следующим образом:
\begin{itemize}
    \item \textbf{Sync Nodes} -- представляет собой объект std::unordered\_set, содержащий id вершин, принадлежащих графу, но объекты которых находятся не в хранилище Owning Nodes.
    \item \textbf{Owning Nodes} -- представляет собой кортеж векторов, позволяющий содержать объекты всех существующих типов вершин.
    \item \textbf{Topology} -- множество рёбер графа, представленное с помощью std::vector.
\end{itemize}
\subsection{Программное представление алгоритма обхода графа}
\label{sec:softwarepresentationgraph}
\textbf{Входные данные}: Кортеж векторов вершин графа, с указанием количества входящих в каждую вершину ребер и множество рёбер графа, представленное неотсортированным вектором.
\par
\textbf{Выходные данные}: Вектор кластеров вершин.
\par
\textbf{Алгоритм}: \begin{enumerate}
    \item Отсортировать вектор рёбер. Назначить каждой вершине индекс, показывающий начало подвектора исходящих из неё рёбер. 
    \item В вектор вершин нулевого кластера заносятся все входные вершины графа. Их кластер назначается текущим.
    \item Пока из вершин текущего кластера есть выходящие ребра, повторяем:
    \begin{enumerate}
        \item Проходим по всем ребрам, выходящим из вершин текущего кластера и инкрементируем счетчик вхождений в иные вершины.
        \item Все иные вершины, счетчик соответствующий которым сравнялся с числом входящих в них на данной итерации рёбер кладем в новый кластер, назначаем его текущим и добавляем в последовательность.
    \end{enumerate}
\end{enumerate}
