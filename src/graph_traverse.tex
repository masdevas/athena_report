\clearpage
\section{Обход графа}
\subsection{Алгоритм обхода графа}
\textbf{Постановка задачи}: Требуется выделить последовательность множеств вершин (назовем их кластерами), работа с которыми может проводиться независимо внутри множеств. Кроме того вершинам $i$-го кластера требуются данные только от вершин из предыдущих кластеров. Подобное разбиение позволит с легкостью записать граф в виде обычной программы на некотором языке программирования, а так же выполнить часть операций параллельно, эффективно задействуя многоядерные системы.
\par
Последовательность кластеров должна обладать следующим свойством: Пусть $(x_1, x_2)$ - произвольное ориентированное ребро в графе. Пусть вершина $x_i$ содержится в кластере с номером $C_i$. Тогда $C_1 < C_2$. Это свойство означает следующее: если кластеры обрабатываются последовательно, начиная с нулевого, то для любой вершины будет верно, что при старте её обработки будут обработаны все входящие в неё вершины, а значит программа сможет работать с их результатами внутри текущей вершины. Для выполнения такого разбиения разработан специальный алгоритм. 
\par
\textbf{Замечание}: Сначала будет дано описание алгоритма для графа без ориентированных циклов, а затем будут даны замечания о работе алгоритма в обходе графов, нарушающих это правило.
\begin{itemize}
    \item \textbf{Входные данные}: Множество вершин графа, разделенное на вектора вершин соответствующих типов, с указанием количества входящих в каждую вершину ребер и множество рёбер графа.
    \item \textbf{Выходные данные}: Последовательность кластеров вершин, обладаюшая вышеописанными свойствами. 
    \item \textbf{Алгоритм}: \begin{enumerate}
        \item В множество вершин нулевого кластера заносятся все входные вершины графа. Их кластер назначается текущим.
        \item Пока из вершин текущего кластера есть выходящие ребра, повторяем:
        \begin{enumerate}
        \item Создаём новый пустой кластер.
            \item Проходим по всем ребрам, выходящим из вершин текущего кластера и инкрементируем счетчик вхождений в иные вершины. Если счётчик числа вхождений в вершину достигает числа входящих в вершину рёбер - вершина добавляется в новый кластер.
        \item Назначаем новый кластер текущим и добавляем в последовательность. 
        \end{enumerate}
    \end{enumerate}
\end{itemize}
\subsection{Доказательство корректности}
\label{sec:validalg}
Докажем корректность алгоритма методом математической индукции при условиях, описанных выше. 
\begin{itemize}
    \item \textbf{База индукции}: На нулевом шаге формируем нулевой кластер из всех входных вершин. Этот кластер сформирован корректно, т.к. между входными вершинами в графе нельзя строить ориентированные пути и предыдущих кластеров нет.
    \item \textbf{Шаг индукции}: Пусть на $i$-ом шаге корректно сформирован $i$-ый кластер. Начнем формировать $(i+1)$-ый кластер. Обозначим некоторое множество вершин графа, удовлетворяющее условию: "В вершины из множества входят лишь рёбра из вершин кластеров с индексами $0, \ldots, i$". Такое множество вершин всегда возможно составить, т.к. в постановке задачи введены необходимые условия и в Лемме \ref{lemma1} доказано, что их достаточно для упреждения такой ситуации. При составлении нового кластера из множества таких вершин он будет корректен по условию, налагаемому на рёбра. Значит его составление и добавление в последовательность означает корректность $i+1$-ого шага алгоритма.
\end{itemize}
\begin{lemma}\label{lemma1}
Если при составлении $(i+1)$-ого кластера множество вершин, удовлетворяющих условию: "В вершины из множества входят лишь рёбра из вершин кластеров с индексами $0, \ldots, i$" пустое, но при этом граф имеет вершины, которые ещё не были пройдены, значит граф имеет ориентированный цикл.
\end{lemma}
\begin{proof}
Рассмотрим ситуации, когда вершину нельзя добавить к составляемому множеству. Можно было бы допустить, что в вершину не входит ни одно ребро. Но такие вершины должны находиться в нулевом кластере. Тогда остается единственный вариант: в любую вершину из множества непройденных входит хотя бы одно ребро из другой непройденной вершины. Тогда на непройденных вершинах можно построить ориентированный цикл.
\end{proof}
\textbf{Замечание}: Данный алгоритм также позволяет проверить граф на ацикличность и на достижимость произвольной вершины из вершин нулевого кластера. \newline
\textbf{Решение}: Во время обхода графа считать число вершин, добавленных в кластеры и сравнивать его с полным числом вершин. Ориентированные циклы могут состоять только из вершин, которые могут иметь входящие и исходящие рёбра. При встрече алгоритма с вершиной ориентированного цикла он не сможет перейти в неё, т.к. существует ребро, являющееся частью этого цикла, но ещё не пройденное алгоритмом, ведь оно исходит из вершины, прежде которой надо посетить ту, в которую алгоритм пытается посетить в данный момент. Следовательно эта вершина не будет добавлена ни в один из кластеров.

\subsection{Программное представление алгоритма обхода графа}
Пусть имеется $k$ входных вершин графа, $n$ вершин в графе всего, $m$ рёбер в графе всего.
\textbf{Входные данные}: Кортеж векторов вершин графа, с указанием количества входящих в каждую вершину ребер и множество рёбер графа, представленное неотсортированным вектором.
\par
\textbf{Выходные данные}: Вектор кластеров вершин.
\par
\textbf{Алгоритм}: \begin{enumerate}
    \item Отсортировать вектор рёбер. Назначить каждой вершине индекс, показывающий начало подвектора исходящих из неё рёбер. Используется сортировка IntroSort - Сложность $O(m*log(m))$
    \item В вектор вершин нулевого кластера заносятся все входные вершины графа. Их кластер назначается текущим. - Сложность $O(k)$
    \item Пока из вершин текущего кластера есть выходящие ребра, повторяем:
    \begin{enumerate}
        \item Проходим по всем ребрам, выходящим из вершин текущего кластера и инкрементируем счетчик вхождений в иные вершины. - Суммарныая сложность $O(m)$
        \item Все иные вершины, счетчик соответствующий которым сравнялся с числом входящих в них на данной итерации рёбер кладем в новый кластер, назначаем его текущим и добавляем в последовательность. - Суммарная сложность $O(n-k)$
    \end{enumerate}
\end{enumerate}
\par
\textbf{Сложность алгоритма}: $O(m*log(m)) + O(m) + O(n-k) + O(k)$
\par
Помимо построения обхода графа процедура устанавливает размерности тензоров для всех внутренних вершин графа автоматически.