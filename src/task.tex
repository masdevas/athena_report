\clearpage
\section{Постановка задачи}
Общая постановка задачи формулируется так: требуется создать программную базу позволяющую пользователю строить нейронную сеть как граф вычислений. Библиотека должна предоставляющий полную функциональность по работе с графом вычислений, такую как:
\begin{enumerate}
    \item Построение графа
    \item Задание операций в функциональные вершины
    \item Загрузка пользовательских данных в входные вершины графа
    \item Генерация графа для вычисления градиента
    \item Компиляция графа
\end{enumerate}
\par
В рамках данной работы под графом вычислений будет пониматься направленный ациклический граф. Граф представляет нейронную сеть. Вершины графа инкапсулируют операции над данными и в частности могут представлять собой слои сети. Ребра графа формируют топологию и связывают вершины между собой. Результат, вычисленный в начале ребра является аргументом для работы окончания ребра. Любые данные, с которыми может работать нейронная сеть, могут быть представлены тензором - многомерным массивом. Операция скрыта внутри вершин графа. Каждая операция принимает один и более входных аргументов и один выходной тензор. Для обучения созданным пользователем графа классическими методами оптимизации необходимо сгенерировать граф, представляющий градиент нейронной сети. Чтобы превратить данные графы в программный код необходимо реализовать процедуру компиляции графа. Во время компиляции графа производится обход графа и генерация программного кода представляющего логику графа на некотором языке программирования. Это позволит скомпилировать спроектированную графом нейронную сеть в реальную статическую или динамическую библиотеку, функции которой сможет вызывать пользователь для выполнения итераций прямого прохода по нейронной сети или выполнения одной итерации оптимизации. Компоненту, предоставляющую эту функциональность, будем называть Core.
\par
Другая часть фреймворка по работе с нейронными сетями, отвечающая за компиляцию представления нейронной сети как программы, которую назовем Backend, рассматривается в данной работе лишь обзорно. Более подробное описание этой компоненты можно найти в работе \cite{coauthor}. Было решено, что код, генерируемый при компиляции графа, будет являться кодом LLVM IR. Этот код является промежуточным представлением программы и может быть оптимизирован и скомпилирован с помощью библиотеки LLVM. Сама библиотека LLVM это продвинутый набор средств для создания компиляторов и проведения различных манипуляций с кодом.
\par
Использование LLVM даст следующие преимущества:
\begin{enumerate}
    \item Быстрая среда исполнения. LLVM позволяет скомпилировать байткод, что дает прирост производительности по сравнению с исполнением графа во время обхода.
    \item Оптимизации. В LLVM встроено множество инструментов для низкоуровневых оптимизаций байткода.
    \item Возможность создать исполняемый файл, который будет содержать только граф вычислений. Это позволит эффективно встраивать обученную модель в пользовательские приложения.
\end{enumerate}
\par
Типичный компилятор на основе LLVM делает лексический разбор исходного кода, строит абстрактное синтаксическое дерево (Abstract Syntax Tree, AST), а затем генерирует LLVM IR - специальное промежуточное представление, которое позже будет преобразовано в машинный код. В случае фреймворка, в качестве AST может выступать граф вычислений. Таким образом, большая часть работы оказывается выполненной.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{ast}
    \caption{Абстрактное синтаксическое дерево}
    \label{task:ast}
\end{figure}
